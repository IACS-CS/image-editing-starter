import React, { useState, useRef } from "react";
import Select, { StylesConfig, SingleValue } from "react-select";
import type { ImageInfo } from "../types";
import { images } from "../images";

type Props = {
  currentImage: ImageInfo;
  onImageSelect: (image: ImageInfo) => void;
};

interface OptionType {
  value: ImageInfo;
  label: string;
}

const ImageSelector: React.FC<Props> = ({ currentImage, onImageSelect }) => {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);

  /**
   * Generated by Gemini3 with prompt to add camera support
   */
  const [showCamera, setShowCamera] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const streamRef = useRef<MediaStream | null>(null);

  const options: OptionType[] = images.map((image) => ({
    value: image,
    label: image.name,
  }));

  const customStyles: StylesConfig<OptionType, false> = {
    option: (provided) => ({
      ...provided,
      display: "flex",
      alignItems: "center",
      padding: 10,
    }),
    singleValue: (provided) => ({
      ...provided,
      display: "flex",
      alignItems: "center",
    }),
  };

  const formatOptionLabel = (image: OptionType) => (
    <div style={{ display: "flex", alignItems: "center" }}>
      <img
        src={image.value.url}
        alt={image.label}
        style={{ width: 30, height: 30, marginRight: 10 }}
      />
      {image.label}
    </div>
  );

  const handleSelectChange = (selectedOption: SingleValue<OptionType>) => {
    // Clean up previous object URL if it was a blob
    if (currentImage.url.startsWith("blob:")) {
      URL.revokeObjectURL(currentImage.url);
    }

    if (selectedOption) {
      onImageSelect(selectedOption.value);
    }
  };

  const selectedOption = options.find(
    (option) => option.value.url === currentImage.url,
  );

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files && event.target.files[0];
    if (file) {
      const fileUrl = URL.createObjectURL(file);
      const newImage = {
        url: fileUrl,
        name: file.name,
        size: file.size,
        filename: file.name,
      };
      setSelectedFile(file);
      onImageSelect(newImage);
    }
  };

  const startCamera = async () => {
    setShowCamera(true);
    // Use a timeout to ensure the video element is rendered
    setTimeout(async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: true,
        });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          streamRef.current = stream;
        }
      } catch (err) {
        console.error("Error accessing camera:", err);
        alert("Could not access camera");
        setShowCamera(false);
      }
    }, 100);
  };

  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }
    setShowCamera(false);
  };

  const takePicture = () => {
    if (videoRef.current) {
      const canvas = document.createElement("canvas");
      canvas.width = videoRef.current.videoWidth;
      canvas.height = videoRef.current.videoHeight;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        // Mirror the image to match the video feed user expectation
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);

        ctx.drawImage(videoRef.current, 0, 0);
        canvas.toBlob((blob) => {
          if (blob) {
            const fileUrl = URL.createObjectURL(blob);
            const newImage = {
              url: fileUrl,
              name: "Camera Capture",
              filename: "capture.png",
            };
            onImageSelect(newImage);
            stopCamera();
          }
        }, "image/png");
      }
    }
  };

  return (
    <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
      <div
        style={{
          display: "flex",
          alignItems: "center",
          gap: 8,
          flexWrap: "wrap",
        }}
      >
        <Select
          value={selectedOption}
          onChange={handleSelectChange}
          options={options}
          styles={customStyles}
          formatOptionLabel={formatOptionLabel}
          isClearable
        />
        <div>
          <input
            id="file-upload"
            type="file"
            accept="image/*"
            onChange={handleFileChange}
          />
        </div>
        <button className="styled-button" onClick={startCamera}>
          Take Picture
        </button>
      </div>

      {showCamera && (
        <>
          <div className="camera-overlay" onClick={stopCamera}></div>
          <div className="camera-container">
            <h3>Take a Picture</h3>
            <video
              ref={videoRef}
              autoPlay
              playsInline
              className="camera-view"
            />
            <div style={{ marginTop: 5, display: "flex", gap: 10 }}>
              <button className="styled-button" onClick={takePicture}>
                Snap Photo
              </button>
              <button className="styled-button" onClick={stopCamera}>
                Cancel
              </button>
            </div>
          </div>
        </>
      )}
    </div>
  );
};

export default ImageSelector;
